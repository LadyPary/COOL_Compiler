README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should now contain the following files:

 Makefile        -> [course dir]/src/PA2/Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [course dir]/src/PA2/lextest.cc
 mycoolc         -> [course dir]/src/PA2/mycoolc
 stringtab.cc    -> [course dir]/src/PA2/stringtab.cc
 utilities.cc    -> [course dir]/src/PA2/utilities.cc
 handle_flags.cc -> [course dir]/src/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the make
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.


        Instructions for turning in the assignment will be posted on the
        course web page.

        GOOD LUCK!

=====================================================
My code's documentation, Zahra Rabbany, 610398124
=====================================================
      %{
	In the "Declarations" section: 

	   1) An integer variable "commentMatch" is defined. It is used to keep track of nested comments.
	   2) A function "append" is defined. It is used to add new characters to the string buffer.
      %}
	
	In the "Definitions" section: 

	   1) First 5 start conditions are defined here:
		1.1) string -> used to handle string constants. 
		1.2) oneLineComment -> used to handle one line comments (i.e. '-- ...'). 
		1.3) nestedComment -> used to handle nested comments (i.e. '(*...*)').  
		1.4) longString -> used to handle long strings (i.e. more than 1024 characters). 
		1.5) badString -> used to handle bad strings (i.e. containing the null character).

	   2) Next 5 types of regular expressions are defined here:
		2.1) Basic definitions (i.e. digit and characters).
		2.2) Special syntactic symbols (i.e. @, ., *).
		2.3) Keywords (i.e. Class, else).
		2.4) Constants (i.e. boolean constants like true and false).
		2.5) Identifies (i.e. type and object identifies).
      %%
	In the "Rules" section: 
	   1) Here "patterns" and "actions" for handling the below cases are written respectively:
		1.1) One line comment -> ignores the comment until a new line is detected.
		1.2) Nested line comment -> ignores the comment and keeps track of opened and closed comments in 
					   the "commentMatch" variable so it can detect "Unmatched *)" error. 
					   It also detects "EOF in comment" error.

		1.3) Single character operators -> returns the single character operators (i.e. @).
		1.4) Multiple character operators -> returns the multiple character operators (i.e. =>).
		1.5) Keywords -> returns the keyword (i.e. class, else).
		1.6) Integer constants -> Adds the integer constants to the "cool.yyval.symbol".
		1.7) Boolean constants -> Adds the boolean constants to the "cool.yyval.boolean".
		1.8) Type and object identifiers -> Adds the identifiers to the "cool.yyval.symbol".
		1.9) String constants -> Handles string constants and detects EOF, null character, 
				        unterminated string, and too long string errors.
				        Adds the valid string constants to "cool.yyval.symbol"
		1.10) White spaces -> ignores the white spaces and keeps track of new line characters.
		1.11) Invalid character -> If there are no matches then the character would be return as an error

      %%
	In the "User subroutines" section: 
	   1) Here I wrote the "append" function which checks whether the string is too long and if not 
	      it would append the new character at the end of the "string_buf". It it is in fact too long
	      it goes into the "longString" state which ignores the letters and only keeps track of new lines.
=====================================================

